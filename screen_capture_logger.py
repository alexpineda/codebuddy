import sys
import time
import threading
from openai import OpenAI
from dotenv import load_dotenv
import os
import select
from utils import capture_and_save_screenshot, log_trace, clear_log, get_active_window_title

load_dotenv()

DEFAULT_CAPTURE_INTERVAL = 15

# Get capture interval from command line argument or use default
if len(sys.argv) > 1:
    try:
        CAPTURE_INTERVAL = float(sys.argv[1])
    except ValueError:
        print(f"Invalid interval provided. Using default: {DEFAULT_CAPTURE_INTERVAL} seconds")
        CAPTURE_INTERVAL = DEFAULT_CAPTURE_INTERVAL
else:
    print(f"No interval provided. Using default: {DEFAULT_CAPTURE_INTERVAL} seconds")
    CAPTURE_INTERVAL = DEFAULT_CAPTURE_INTERVAL

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

screenshot_counter = 0

TRACE_LOG_FILE = "./trace_log.txt"


capture_paused = False
user_input_queue = []

def capture_screen():
    global screenshot_counter
    
    filename, base64_image = capture_and_save_screenshot(screenshot_counter)
    screenshot_counter += 1

    # Get the active window title
    active_window_title = get_active_window_title()

    # Send screenshot to GPT-4 Vision model
    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "The following is a screenshot of a series of screenshots.\n" +
                    "The response will be added to an 'activity' log file, so only output relevant information.\n" +
                    "In the application that is purposed around this, the user may ask questions about their activity log in order to aid in their productivity and act as a short term memory."
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": "Describe what's happening in this screenshot. The active window is: " + active_window_title
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/png;base64,{base64_image}"
                            }
                        }
                    ]
                }
            ],
            max_tokens=500
        )
        
        vision_response = response.choices[0].message.content
        log_trace(f"Saved screenshot: {filename}", TRACE_LOG_FILE)
        log_trace(f"Active window: {active_window_title}", TRACE_LOG_FILE)
        log_trace(vision_response, TRACE_LOG_FILE)
        # print(f"Saved screenshot: {filename}")
        # print(f"Active window: {active_window_title}")
        # print(f"Vision model response: {vision_response}")
    except Exception as e:
        log_trace(f"Failed to send screenshot to vision model: {e}", TRACE_LOG_FILE)
        print(f"Failed to send screenshot to vision model: {e}")


def prompt_user():
    global capture_paused
    while True:
        user_input = input("Enter your question (or 'exit' to quit, 'reset' to clear the log, 'continue' to resume capturing): ")
        if user_input.lower() == 'reset':
            clear_log(TRACE_LOG_FILE)
            print("Log has been cleared.")
        elif user_input.lower() == 'continue':
            capture_paused = False
            print("Resuming screen capture...")
            return
        elif user_input.lower() == 'exit':
            print("Exiting...")
            os._exit(0)
        elif user_input:
            print("Asking codebuddy: " + user_input, end='', flush=True)
            # Log the user's inquiry
            log_trace(f"USER INQUIRY: {user_input}", TRACE_LOG_FILE)
            
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are an assistant. Provide an appropriate response based on the given users activity log. The log was generated by capturing screenshots of the users activity and using a vision model to write the log. The log may also contain previous responses from the user and the assistant."},
                    {"role": "user", "content": f"The user asked: '{user_input}'. Based on the following log, provide an appropriate response:\n\n{open(TRACE_LOG_FILE, 'r').read()}"}
                ]
            )
            assistant_response = response.choices[0].message.content
            
            # Log the assistant's response
            log_trace(f"ASSISTANT RESPONSE: {assistant_response}", TRACE_LOG_FILE)
            
            print(assistant_response)

            print("Enter another question or type 'continue' to resume capturing.")
        else:
            print("Please enter a valid input.")

def capture_loop():
    global capture_paused
    while True:
        time.sleep(CAPTURE_INTERVAL)
        if not capture_paused:
            capture_screen()

def check_for_input():
    global capture_paused, user_input_queue
    while True:
        rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
        if rlist:
            user_input = sys.stdin.readline().strip()
            if user_input == '':  # Check for empty input (Enter key press)
                capture_paused = True
                user_input_queue.append("inquiry")

if __name__ == "__main__":
    print("Hi this is codebuddy! I'll record your screen periodically and you can ask questions as you work away!")
    print(f"Screen capture interval set to {CAPTURE_INTERVAL} seconds")
    print("Press Enter at any time to pause and enter inquiry mode.")
    
    clear_log(TRACE_LOG_FILE)

    # Start the capture screen function in a separate thread
    capture_thread = threading.Thread(target=capture_loop)
    capture_thread.daemon = True
    capture_thread.start()

    # Start the input checking thread
    input_thread = threading.Thread(target=check_for_input)
    input_thread.daemon = True
    input_thread.start()

    try:
        while True:
            if user_input_queue:
                action = user_input_queue.pop(0)
                if action == "inquiry":
                    print("\nEntering inquiry mode. Screen capture paused.")
                    prompt_user()
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nExiting...")
    finally:
        os._exit(0)
